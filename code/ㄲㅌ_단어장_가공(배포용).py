# -*- coding: utf-8 -*-
"""ㄲㅌ 단어장 가공(배포용).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f71GzR8pnjhtbO3eEubzjk23FgHSphxn

# ha_sy.py
"""

__all__ = ["split_syllable_char", "split_syllables",
           "join_jamos", "join_jamos_char",
           "CHAR_INITIALS", "CHAR_MEDIALS", "CHAR_FINALS"]

import itertools

INITIAL = 0x001
MEDIAL = 0x010
FINAL = 0x100
CHAR_LISTS = {
    INITIAL: list(map(chr, [
        0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139,
        0x3141, 0x3142, 0x3143, 0x3145, 0x3146, 0x3147,
        0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d,
        0x314e
    ])),
    MEDIAL: list(map(chr, [
        0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154,
        0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a,
        0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,
        0x3161, 0x3162, 0x3163
    ])),
    FINAL: list(map(chr, [
        0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136,
        0x3137, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d,
        0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3144,
        0x3145, 0x3146, 0x3147, 0x3148, 0x314a, 0x314b,
        0x314c, 0x314d, 0x314e
    ]))
}
CHAR_INITIALS = CHAR_LISTS[INITIAL]
CHAR_MEDIALS = CHAR_LISTS[MEDIAL]
CHAR_FINALS = CHAR_LISTS[FINAL]
CHAR_SETS = {k: set(v) for k, v in CHAR_LISTS.items()}
CHARSET = set(itertools.chain(*CHAR_SETS.values()))
CHAR_INDICES = {k: {c: i for i, c in enumerate(v)}
                for k, v in CHAR_LISTS.items()}


def is_hangul_syllable(c):
    return 0xac00 <= ord(c) <= 0xd7a3  # Hangul Syllables


def is_hangul_jamo(c):
    return 0x1100 <= ord(c) <= 0x11ff  # Hangul Jamo


def is_hangul_compat_jamo(c):
    return 0x3130 <= ord(c) <= 0x318f  # Hangul Compatibility Jamo


def is_hangul_jamo_exta(c):
    return 0xa960 <= ord(c) <= 0xa97f  # Hangul Jamo Extended-A


def is_hangul_jamo_extb(c):
    return 0xd7b0 <= ord(c) <= 0xd7ff  # Hangul Jamo Extended-B


def is_hangul(c):
    return (is_hangul_syllable(c) or
            is_hangul_jamo(c) or
            is_hangul_compat_jamo(c) or
            is_hangul_jamo_exta(c) or
            is_hangul_jamo_extb(c))


def is_supported_hangul(c):
    return is_hangul_syllable(c) or is_hangul_compat_jamo(c)


def check_hangul(c, jamo_only=False):
    if not ((jamo_only or is_hangul_compat_jamo(c)) or is_supported_hangul(c)):
        raise ValueError(f"'{c}' is not a supported hangul character. "
                         f"'Hangul Syllables' (0xac00 ~ 0xd7a3) and "
                         f"'Hangul Compatibility Jamos' (0x3130 ~ 0x318f) are "
                         f"supported at the moment.")


def get_jamo_type(c):
    check_hangul(c)
    assert is_hangul_compat_jamo(c), f"not a jamo: {ord(c):x}"
    return sum(t for t, s in CHAR_SETS.items() if c in s)


def split_syllable_char(c):
    """
    Splits a given korean syllable into its components. Each component is
    represented by Unicode in 'Hangul Compatibility Jamo' range.

    Arguments:
        c: A Korean character.

    Returns:
        A triple (initial, medial, final) of Hangul Compatibility Jamos.
        If no jamo corresponds to a position, `None` is returned there.

    Example:
        >>> split_syllable_char("안")
        ("ㅇ", "ㅏ", "ㄴ")
        >>> split_syllable_char("고")
        ("ㄱ", "ㅗ", None)
        >>> split_syllable_char("ㅗ")
        (None, "ㅗ", None)
        >>> split_syllable_char("ㅇ")
        ("ㅇ", None, None)
    """
    check_hangul(c)
    if len(c) != 1:
        raise ValueError("Input string must have exactly one character.")

    init, med, final = None, None, None
    if is_hangul_syllable(c):
        offset = ord(c) - 0xac00
        x = (offset - offset % 28) // 28
        init, med, final = x // 21, x % 21, offset % 28
        if not final:
            final = None
        else:
            final -= 1
    else:
        pos = get_jamo_type(c)
        if pos & INITIAL == INITIAL:
            pos = INITIAL
        elif pos & MEDIAL == MEDIAL:
            pos = MEDIAL
        elif pos & FINAL == FINAL:
            pos = FINAL
        idx = CHAR_INDICES[pos][c]
        if pos == INITIAL:
            init = idx
        elif pos == MEDIAL:
            med = idx
        else:
            final = idx
    return tuple(CHAR_LISTS[pos][idx] if idx is not None else None
                 for pos, idx in
                 zip([INITIAL, MEDIAL, FINAL], [init, med, final]))


def split_syllables(s, ignore_err=True, pad=None):
    """
    Performs syllable-split on a string.

    Arguments:
        s (str): A string (possibly mixed with non-Hangul characters).
        ignore_err (bool): If set False, it ensures that all characters in
            the string are Hangul-splittable and throws a ValueError otherwise.
            (default: True)
        pad (str): Pad empty jamo positions (initial, medial, or final) with
            `pad` character. This is useful for cases where fixed-length
            strings are needed. (default: None)

    Returns:
        Hangul-split string

    Example:
        >>> split_syllables("안녕하세요")
        "ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ"
        >>> split_syllables("안녕하세요~~", ignore_err=False)
        ValueError: encountered an unsupported character: ~ (0x7e)
        >>> split_syllables("안녕하세요ㅛ", pad="x")
        'ㅇㅏㄴㄴㅕㅇㅎㅏxㅅㅔxㅇㅛxxㅛx'
    """

    def try_split(c):
        try:
            return split_syllable_char(c)
        except ValueError:
            if ignore_err:
                return (c,)
            raise ValueError(f"encountered an unsupported character: "
                             f"{c} (0x{ord(c):x})")

    s = map(try_split, s)
    if pad is not None:
        tuples = map(lambda x: tuple(pad if y is None else y for y in x), s)
    else:
        tuples = map(lambda x: filter(None, x), s)
    return "".join(itertools.chain(*tuples))


def join_jamos_char(init, med, final=None):
    """
    Combines jamos into a single syllable.

    Arguments:
        init (str): Initial jao.
        med (str): Medial jamo.
        final (str): Final jamo. If not supplied, the final syllable is made
            without the final. (default: None)

    Returns:
        A Korean syllable.
    """
    chars = (init, med, final)
    for c in filter(None, chars):
        check_hangul(c, jamo_only=True)

    idx = tuple(CHAR_INDICES[pos][c] if c is not None else c
                for pos, c in zip((INITIAL, MEDIAL, FINAL), chars))
    init_idx, med_idx, final_idx = idx
    # final index must be shifted once as
    # final index with 0 points to syllables without final
    final_idx = 0 if final_idx is None else final_idx + 1
    return chr(0xac00 + 28 * 21 * init_idx + 28 * med_idx + final_idx)


def join_jamos(s, ignore_err=True):
    """
    Combines a sequence of jamos to produce a sequence of syllables.

    Arguments:
        s (str): A string (possible mixed with non-jamo characters).
        ignore_err (bool): If set False, it will ensure that all characters
            will be consumed for the making of syllables. It will throw a
            ValueError when it fails to do so. (default: True)

    Returns:
        A string

    Example:
        >>> join_jamos("ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ")
        "안녕하세요"
        >>> join_jamos("ㅇㅏㄴㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ")
        "안ㄴ녕하세요"
        >>> join_jamos()
    """
    last_t = 0
    queue = []
    new_string = ""

    def flush(n=0):
        new_queue = []
        while len(queue) > n:
            new_queue.append(queue.pop())
        if len(new_queue) == 1:
            if not ignore_err:
                raise ValueError(f"invalid jamo character: {new_queue[0]}")
            result = new_queue[0]
        elif len(new_queue) >= 2:
            try:
                result = join_jamos_char(*new_queue)
            except (ValueError, KeyError):
                # Invalid jamo combination
                if not ignore_err:
                    raise ValueError(f"invalid jamo characters: {new_queue}")
                result = "".join(new_queue)
        else:
            result = None
        return result

    for c in s:
        if c not in CHARSET:
            if queue:
                new_c = flush() + c
            else:
                new_c = c
            last_t = 0
        else:
            t = get_jamo_type(c)
            new_c = None
            if t & FINAL == FINAL:
                if not (last_t == MEDIAL):
                    new_c = flush()
            elif t == INITIAL:
                new_c = flush()
            elif t == MEDIAL:
                if last_t & INITIAL == INITIAL:
                    new_c = flush(1)
                else:
                    new_c = flush()
            last_t = t
            queue.insert(0, c)
        if new_c:
            new_string += new_c
    if queue:
        new_string += flush()
    return new_string

"""# 파일업로드///"""

from google.colab import files

uploaded = files.upload()

for filename in uploaded.keys():
    print('업로드된 파일 "{name}" 길이는 {length} 바이트입니다.'.format(
        name=filename, length=len(uploaded[filename])))

"""# 파일 합성"""

def process_files_and_merge():
    try:
        # 파일 이름 입력
        file1_name = input("첫 번째 파일 이름을 입력하세요: ")
        file2_name = input("두 번째 파일 이름을 입력하세요: ")

        # 첫 번째 파일 내용을 읽어와 단어들을 줄바꿈으로 구분
        with open(file1_name, 'r', encoding='utf-8') as file1:
            content1 = file1.read().replace(' ', '\n').replace('\t', '\n').splitlines()

        # 두 번째 파일 내용을 읽어와 단어들을 줄바꿈으로 구분
        with open(file2_name, 'r', encoding='utf-8') as file2:
            content2 = file2.read().replace(' ', '\n').replace('\t', '\n').splitlines()

        # 두 파일의 단어들을 합쳐서 중복을 제거한 후 새로운 리스트로 저장
        merged_words = list(set(content1 + content2))

        # 중복 제거된 단어들을 새 파일에 씀
        with open('merged_file.txt', 'w', encoding='utf-8') as merged_file:
            for word in merged_words:
                merged_file.write(word + "\n")

        print("두 파일의 단어들을 합쳐 새 파일을 생성했습니다. 중복된 단어가 제거되었습니다.")

    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

process_files_and_merge()

"""# 단어 제거"""

def remove_character_from_file(file_name, character):
    try:
        # 파일 읽기
        with open(file_name, 'r', encoding='utf-8') as file:
            data = file.read()

        # 입력 받은 글자 삭제
        data = data.replace(character, '')

        # 파일에 쓰기
        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(data)

        print(f"'{character}'를 삭제한 결과를 {file_name}에 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

# 사용자 입력 받기
file_name = input("파일 이름을 입력하세요: ")
character_to_remove = input("삭제하고 싶은 글자를 입력하세요: ")

# 함수 호출하여 입력 받은 글자 삭제
remove_character_from_file(file_name, character_to_remove)

"""# 줄바꿈 프로그램"""

def space_to_newline():
    file_name = input('파일이름을 입력하세요: ')

    try:
        with open(file_name, 'r', encoding='utf-8') as file:
            content = file.read().replace(' ', '\n')

        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(content)
        print(f"파일 '{file_name}'의 띄어쓰기가 줄바꿈으로 변경되었습니다.")

    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

space_to_newline()

"""# 띄어쓰기"""

def split_characters(input_filename, output_filename):
    try:
        with open(input_filename, 'r', encoding='utf-8') as file:
            words = file.read().split()

        characters = ' '.join(' '.join(word) for word in words)  # 단어를 한 글자씩 띄어쓰기로 변환

        with open(output_filename, 'w', encoding='utf-8') as output_file:
            output_file.write(characters)  # 한 글자씩 띄어쓰기된 문자열을 새 파일에 저장
        print(f"파일 '{output_filename}'에 한 글자씩 띄어쓰기하여 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

input_file = input('파일이름 입력: ')  # 입력 파일명
output_file = input('출력 파일이름명 입력: ')  # 결과 파일명

split_characters(input_file, output_file)

"""# 중복 제거"""

#덮어씌우기됨
def remove_duplicates_and_save():
    file_name = input('파일이름 입력: ')

    try:
        with open(file_name, 'r', encoding='utf-8') as file:
            words = file.read().splitlines()
            unique_words = list(set(words))

        with open(file_name, 'w', encoding='utf-8') as file:
            for word in unique_words:
                file.write(word + "\n")
        print(f"파일 '{file_name}'의 중복된 단어가 삭제되고 덮어씌워졌습니다.")

    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

remove_duplicates_and_save()

#새파일저장


def remove_duplicates(input_filename, output_filename):
    try:
        with open(input_filename, 'r', encoding='utf-8') as file:
            words = file.read().split()

        unique_words = list(set(words))  # 중복 제거

        with open(output_filename, 'w', encoding='utf-8') as output_file:
            output_file.write(' '.join(unique_words))  # 중복 제거된 단어들을 새 파일에 저장
        print(f"파일 '{output_filename}'에 중복된 단어들을 제거하여 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

input_file = input('파일이름 입력: ') # 입력 파일명
output_file = input('출력 파일명 입력: ')  # 결과 파일명

remove_duplicates(input_file, output_file)

"""# ㄱㄴㄷ순 정렬"""

def sort_words_in_file_and_save():
    file_name = input('파일이름 입력: ')

    try:
        with open(file_name, 'r', encoding='utf-8') as file:
            words = file.read().split()
            sorted_words = sorted(words)

        with open(file_name, 'w', encoding='utf-8') as file:
            for word in sorted_words:
                file.write(word + "\n")
        print(f"파일 '{file_name}'의 내용이 가나다순으로 정렬되어 덮어씌워졌습니다.")

    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

sort_words_in_file_and_save()

"""# 앞 글자 추출"""

def extract_first_letters(input_filename, output_filename):
    try:
        with open(input_filename, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            first_letters = [line[0] for line in lines if line.strip()]  # 각 줄의 첫 번째 글자 추출

        with open(output_filename, 'w', encoding='utf-8') as output_file:
            output_file.write(''.join(first_letters))  # 추출된 첫 글자를 새 파일에 저장
        print(f"파일 '{output_filename}'에 첫 글자들을 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

input_file = input('파일이름 입력: ')  # 입력 파일명
output_file = input('출력 파일명 입력: ')  # 결과 파일명

extract_first_letters(input_file, output_file)

"""# 끝나는 단어 추출"""

def extract_last_letters(input_file, output_file):
    try:
        with open(input_file, 'r', encoding='utf-8') as file:
            lines = file.readlines()

        last_letters = []

        for line in lines:
            words = line.split()
            if words:
                last_word = words[-1]
                last_letters.append(last_word[-1])  # 각 줄의 마지막 단어의 마지막 글자만 추출하여 리스트에 추가

        with open(output_file, 'w', encoding='utf-8') as output:
            output.write(' '.join(last_letters))  # 추출된 끝 글자들을 새 파일에 저장

        print(f"끝 글자를 '{output_file}' 파일로 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

input_file = input("입력 파일 이름을 입력하세요: ")
output_file = input("출력 파일 이름을 입력하세요: ")
extract_last_letters(input_file, output_file)

"""# 미리보기"""

def preview_text_file_by_filename():
    try:
        file_name = input("파일 이름을 입력하세요: ")
        with open(file_name, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            preview_lines = lines[:10]  # 파일의 처음 10줄만 가져옵니다.
            for line in preview_lines:
                print(line.strip())  # 줄 바꿈 문자 제거 후 출력합니다.
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

preview_text_file_by_filename()

"""# 빈줄제거"""

def remove_empty_lines_by_filename():
    try:
        file_name = input("파일 이름을 입력하세요: ")
        with open(file_name, 'r', encoding='utf-8') as file:
            lines = file.readlines()

        # 빈 줄을 제거합니다.
        non_empty_lines = [line for line in lines if line.strip()]

        with open(file_name, 'w', encoding='utf-8') as file:
            file.writelines(non_empty_lines)

        print(f'"{file_name}" 파일에서 빈 줄을 제거했습니다.')
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

remove_empty_lines_by_filename()

"""# 단어장 정렬 2(같은 단어 끼리 모아두는 )"""

def rearrange_words(input_file, output_file):
    try:
        with open(input_file, 'r', encoding='utf-8') as file:
            words = file.read().split()

        words.sort()  # 단어들을 알파벳순으로 정렬

        rearranged_text = ''
        current_char = None

        for word in words:
            if not current_char or word.startswith(current_char):
                rearranged_text += word + ' '
            else:
                rearranged_text += '\n \n' + word + ' '
            current_char = word[0]

        with open(output_file, 'w', encoding='utf-8') as file:
            file.write(rearranged_text.strip())  # 문자열 시작과 끝의 공백 제거 후 파일에 저장

        print(f"단어를 '{output_file}' 파일로 재배열하여 저장했습니다.")
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")

input_file = input("입력 파일 이름을 입력하세요: ")
output_file = input("출력 파일 이름을 입력하세요: ")
rearrange_words(input_file, output_file)

"""# 단어수 체크"""

# 텍스트 파일 이름 입력 받기
file_name = input("텍스트 파일 이름을 입력하세요: ")

try:
    with open(file_name, 'r', encoding='utf-8') as file:
        text = file.read()
        words = text.split()
        word_count = len(words)
        print(f"입력된 텍스트파일에는 총 {word_count}개의 단어가 있습니다.")
except FileNotFoundError:
    print("파일을 찾을 수 없습니다.")

"""# 미션단어 추출v3(한국어)"""

file_name=input('파일 이름 입력:')
KKK={}
for i in ['가','나','다','라','마','바','사','아','자','차','카','타','파','하']:
  KKK[i]=[]
def is_mission(word,onemissionin):
  global KKK
  include=1 if onemissionin else 2
  mission_list=['가','나','다','라','마','바','사','아','자','차','카','타','파','하']
  for miss in mission_list:
    if word.count(miss)>=include:
      KKK[miss].append((word,word.count(miss)))
  return
def words_sort1():
  global KKK
  for keyss,wordss in KKK.items():
    ttt=sorted(wordss,key=lambda x:(-x[1],-len(x[0]),x[0]))
    op=[]
    for wo in ttt:
      op.append(wo[0])
    KKK[keyss]=op
  return

def words_sort2():
  global KKK
  global yyy,ww
  pol={}
  for i in ['가','나','다','라','마','바','사','아','자','차','카','타','파','하']:
    pol[i]=[]
  for keyss,wordss in KKK.items():
    yyy=sorted(wordss,key=lambda x:(x[0],-x[1],-len(x[0])))
    ko=None
    ww=[]
    for x,m in yyy:

      if ko==None:
        ko=x[0]
        ww.append(x)
      else:
        if ko==x[0]:
          ww.append(x)
        else:
          ww=sorted(ww,key=lambda x:(-(x.count(keyss)),-len(x)))
          pol[keyss].append(ww)
          ww=[]
          ww.append(x)
          ko=x[0]
    pol[keyss].append(ww)
  return pol

def write_f2(dic,file_name):
  with open(file_name,'w',encoding='utf-8') as f:
    for ke,arrs in dic.items():
      if not arrs:
        continue
      f.write(f'[[{ke}]]\n')
      for arrz in arrs:
        f.write(f'[{arrz[0][0]}]\n')
        f.write('\n'.join(arrz))
        f.write('\n\n')
  return

def write_f1(file_name):
  global KKK
  with open(file_name,'w',encoding='utf-8') as f:
    for keyss,wordss in KKK.items():
      f.write(f'[{keyss}]\n')
      f.write('\n'.join(wordss))
      f.write('\n\n')
  return
def words_sort3():
  global KKK
  op=[]
  for keyss,wordss in KKK.items():
    for word,x in wordss:
      op.append(word)
  return (sorted(list(set(op)),key=len,reverse=True))
def write_f3(arr,file_name):
  global KKK
  with open(file_name,'w',encoding='utf-8') as f:
    f.write('\n'.join(arr))
def words_sort4():
  global KKK
  op={}
  for wordss in KKK.values():
    for wor,p in wordss:
      if wor[0] in op:
        if wor not in op[wor[0]]:
          op[wor[0]].append(wor)
      else:
        op[wor[0]]=[wor]
  return op
def write_f4(dic,file_name):
  dic=dict(sorted(dic.items()))
  with open(file_name,'w',encoding='utf-8') as f:
    for keyss,arr in dic.items():
      f.write(f'[{keyss}]\n')
      f.write('\n'.join(arr))
      f.write('\n\n')
try:
  with open(file_name,'r',encoding='utf-8') as f:
    wordz=f.read().split('\n')
  while 1:
    print('정렬 모드를 설정해주십시오.')
    print('1:1순위 미션글자 포함순,2순위 글자길이,3순위 ㄱㄴㄷ순\n2:1순위,ㄱㄴㄷ순 2순위:미션글자 포함순,3순위 글자길이순\n3:글자 길이순\n4:ㄱㄴㄷ순')
    mods=input('위에 숫자중 고르십시오.:')
    if mods not in ('1','2','3','4'):
      continue
    break
  while 1:
    pp = input('1미를 포함하시겠습니까? Y/N로 입력하십시오.:')
    if pp not in ('Y','N','y','n'):
      continue
    pp=pp.upper()
    Hn=True if pp=='Y' else False
    break
  for w in wordz:
    is_mission(w,Hn)
  lo=[]
  for keyy,ii in KKK.items():
    if not ii:
      lo.append(keyy)
  for i in lo:
    del KKK[i]
  output_file_name=input('출력 파일 이름을 입력하십시오:')
  if mods=='1':
    swq=words_sort1()
    write_f1(output_file_name)
  elif mods=='2':
    swq=words_sort2()
    write_f2(swq,output_file_name)
  elif mods=='3':
    swq=words_sort3()
    write_f3(swq,output_file_name)
  elif mods=='4':
    swq=words_sort4()
    write_f4(swq,output_file_name)
  print('완료되었습니다.')
except FileNotFoundError:
  print('파일을 찾을수 없습니다.')
except Exception as e:
  print(f'{e} 예외가 발생했습니다.\n해당 사진을 카페 댓글로 알려주십시오.\n입력에 넣으신 파일도 필요가능성이 있습니다.')

"""# 미션단어 추출(영어) - 1"""

from collections import Counter

# 여러 단어에서 리스트에 있는 글자와 개수를 반환하는 함수
def process_words(words, lst):
    results = []

    def count_letters_in_list(word, lst):
        count = Counter({letter: 0 for letter in set(lst)})
        for letter in set(lst):
            count[letter] = word.count(letter)
        return count

    for word in words:
        result = count_letters_in_list(word, lst)
        output = f"{word}  ["
        sorted_result = sorted(result.items(), key=lambda x: (-x[1], x[0]))
        for letter, count in sorted_result:
            output += f"{letter}:{count} "
        output = output.rstrip()
        output += "]"
        results.append(output)
    return results


mission_letter = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
input_file = input('입력 파일이름을 입력하세요: ')
output_file = input('출력 파일이름을 입력하세요: ')
try:
  with open(input_file,'r',encoding='utf-8') as file:
    words = file.read().splitlines()
  pri_list = process_words(words, mission_letter)

  with open(output_file,'w',encoding='utf-8') as file:
    file.write('\n'.join(pri_list))

  print(f'{output_file}에 저장하였습니다.')
except FileNotFoundError:
  print('파일을 찾을수 없습니다.')

"""# 미션단어 추출(영어)-2"""

from collections import Counter

def process_and_save(input_file, output_file, mission_letter):
    def count_letters_in_list(word, lst):
        count = Counter({letter: 0 for letter in set(lst)})
        for letter in set(lst):
            if letter in word:
                count[letter] = word.count(letter)
        return count

    def process_words(words, lst):
        results = []
        for word in words:
            result = count_letters_in_list(word, lst)
            output = f"{word} ["
            for letter, count in sorted(result.items(), key=lambda x: (-x[1], x[0])):
                if count > 0:
                    output += f"{letter}:{count} "
            output = output.rstrip()
            output += "]"
            results.append(output)
        return results

    try:
        with open(input_file, 'r', encoding='utf-8') as file:
            words = file.read().split()

        pri_list = process_words(words, mission_letter)

        with open(output_file, 'w', encoding='utf-8') as file:
            file.write('\n'.join(pri_list))
        print(f'{output_file}에 저장했습니다.')

    except FileNotFoundError:
        print('파일을 찾을 수 없습니다.')

# 사용 예시:
mission_letter = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

input_file = input('파일 이름을 입력하세요: ')
output_file = input('출력 파일 이름을 입력하세요: ')

process_and_save(input_file, output_file, mission_letter)

"""# X로 시작하는 단어"""

file_path = input('파일이름을 입력하세요: ')  # 단어장 파일 경로 설정
start_letter = input("시작할 첫 글자를 입력하세요: ")  # 사용자로부터 첫 글자 입력 받기
output_file = input('출력 파일명을 입력하세요: ')

try:
  with open(file_path, 'r', encoding='utf-8') as file:
      words = file.read().splitlines()  # 파일의 각 줄을 단어로 분리하여 리스트로 저장

  wordss_list = []
  for word in words:
      if word.startswith(start_letter):
        wordss_list.append(word)
        pass
  with open(output_file,'w',encoding='utf-8') as file:
    file.write('\n'.join(wordss_list))
  print(f'{output_file}에 <{start_letter}>로 시작하는 단어를 저장하였습니다.')
except FileNotFoundError:
  print('파일을 찾을수 없습니다.')

"""# X로 끝나는 단어"""

file_path = input('파일이름을 입력하세요: ')  # 단어장 파일 경로 설정
end_letter = input("끝나는 글자를 입력하세요: ")  # 사용자로부터 첫 글자 입력 받기
output_file = input('출력 파일명을 입력하세요: ')

try:
  with open(file_path, 'r', encoding='utf-8') as file:
      words = file.read().splitlines()  # 파일의 각 줄을 단어로 분리하여 리스트로 저장

  wordss_list = []
  for word in words:
      if word.endswith(end_letter):
        wordss_list.append(word)
        pass
  with open(output_file,'w',encoding='utf-8') as file:
    file.write('\n'.join(wordss_list))
  print(f'{output_file}에 <{end_letter}>로 끝나는 단어를 저장하였습니다.')
except FileNotFoundError:
  print('파일을 찾을수 없습니다.')

"""# 돌림단어 추출"""

__all__ = ["split_syllable_char", "split_syllables",
           "join_jamos", "join_jamos_char",
           "CHAR_INITIALS", "CHAR_MEDIALS", "CHAR_FINALS"]

import itertools

INITIAL = 0x001
MEDIAL = 0x010
FINAL = 0x100
CHAR_LISTS = {
    INITIAL: list(map(chr, [
        0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139,
        0x3141, 0x3142, 0x3143, 0x3145, 0x3146, 0x3147,
        0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d,
        0x314e
    ])),
    MEDIAL: list(map(chr, [
        0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154,
        0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a,
        0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,
        0x3161, 0x3162, 0x3163
    ])),
    FINAL: list(map(chr, [
        0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136,
        0x3137, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d,
        0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3144,
        0x3145, 0x3146, 0x3147, 0x3148, 0x314a, 0x314b,
        0x314c, 0x314d, 0x314e
    ]))
}
CHAR_INITIALS = CHAR_LISTS[INITIAL]
CHAR_MEDIALS = CHAR_LISTS[MEDIAL]
CHAR_FINALS = CHAR_LISTS[FINAL]
CHAR_SETS = {k: set(v) for k, v in CHAR_LISTS.items()}
CHARSET = set(itertools.chain(*CHAR_SETS.values()))
CHAR_INDICES = {k: {c: i for i, c in enumerate(v)}
                for k, v in CHAR_LISTS.items()}


def is_hangul_syllable(c):
    return 0xac00 <= ord(c) <= 0xd7a3  # Hangul Syllables


def is_hangul_jamo(c):
    return 0x1100 <= ord(c) <= 0x11ff  # Hangul Jamo


def is_hangul_compat_jamo(c):
    return 0x3130 <= ord(c) <= 0x318f  # Hangul Compatibility Jamo


def is_hangul_jamo_exta(c):
    return 0xa960 <= ord(c) <= 0xa97f  # Hangul Jamo Extended-A


def is_hangul_jamo_extb(c):
    return 0xd7b0 <= ord(c) <= 0xd7ff  # Hangul Jamo Extended-B


def is_hangul(c):
    return (is_hangul_syllable(c) or
            is_hangul_jamo(c) or
            is_hangul_compat_jamo(c) or
            is_hangul_jamo_exta(c) or
            is_hangul_jamo_extb(c))


def is_supported_hangul(c):
    return is_hangul_syllable(c) or is_hangul_compat_jamo(c)


def check_hangul(c, jamo_only=False):
    if not ((jamo_only or is_hangul_compat_jamo(c)) or is_supported_hangul(c)):
        raise ValueError(f"'{c}' is not a supported hangul character. "
                         f"'Hangul Syllables' (0xac00 ~ 0xd7a3) and "
                         f"'Hangul Compatibility Jamos' (0x3130 ~ 0x318f) are "
                         f"supported at the moment.")


def get_jamo_type(c):
    check_hangul(c)
    assert is_hangul_compat_jamo(c), f"not a jamo: {ord(c):x}"
    return sum(t for t, s in CHAR_SETS.items() if c in s)


def split_syllable_char(c):
    """
    Splits a given korean syllable into its components. Each component is
    represented by Unicode in 'Hangul Compatibility Jamo' range.

    Arguments:
        c: A Korean character.

    Returns:
        A triple (initial, medial, final) of Hangul Compatibility Jamos.
        If no jamo corresponds to a position, `None` is returned there.

    Example:
        >>> split_syllable_char("안")
        ("ㅇ", "ㅏ", "ㄴ")
        >>> split_syllable_char("고")
        ("ㄱ", "ㅗ", None)
        >>> split_syllable_char("ㅗ")
        (None, "ㅗ", None)
        >>> split_syllable_char("ㅇ")
        ("ㅇ", None, None)
    """
    check_hangul(c)
    if len(c) != 1:
        raise ValueError("Input string must have exactly one character.")

    init, med, final = None, None, None
    if is_hangul_syllable(c):
        offset = ord(c) - 0xac00
        x = (offset - offset % 28) // 28
        init, med, final = x // 21, x % 21, offset % 28
        if not final:
            final = None
        else:
            final -= 1
    else:
        pos = get_jamo_type(c)
        if pos & INITIAL == INITIAL:
            pos = INITIAL
        elif pos & MEDIAL == MEDIAL:
            pos = MEDIAL
        elif pos & FINAL == FINAL:
            pos = FINAL
        idx = CHAR_INDICES[pos][c]
        if pos == INITIAL:
            init = idx
        elif pos == MEDIAL:
            med = idx
        else:
            final = idx
    return tuple(CHAR_LISTS[pos][idx] if idx is not None else None
                 for pos, idx in
                 zip([INITIAL, MEDIAL, FINAL], [init, med, final]))


def split_syllables(s, ignore_err=True, pad=None):
    """
    Performs syllable-split on a string.

    Arguments:
        s (str): A string (possibly mixed with non-Hangul characters).
        ignore_err (bool): If set False, it ensures that all characters in
            the string are Hangul-splittable and throws a ValueError otherwise.
            (default: True)
        pad (str): Pad empty jamo positions (initial, medial, or final) with
            `pad` character. This is useful for cases where fixed-length
            strings are needed. (default: None)

    Returns:
        Hangul-split string

    Example:
        >>> split_syllables("안녕하세요")
        "ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ"
        >>> split_syllables("안녕하세요~~", ignore_err=False)
        ValueError: encountered an unsupported character: ~ (0x7e)
        >>> split_syllables("안녕하세요ㅛ", pad="x")
        'ㅇㅏㄴㄴㅕㅇㅎㅏxㅅㅔxㅇㅛxxㅛx'
    """

    def try_split(c):
        try:
            return split_syllable_char(c)
        except ValueError:
            if ignore_err:
                return (c,)
            raise ValueError(f"encountered an unsupported character: "
                             f"{c} (0x{ord(c):x})")

    s = map(try_split, s)
    if pad is not None:
        tuples = map(lambda x: tuple(pad if y is None else y for y in x), s)
    else:
        tuples = map(lambda x: filter(None, x), s)
    return "".join(itertools.chain(*tuples))


def join_jamos_char(init, med, final=None):
    """
    Combines jamos into a single syllable.

    Arguments:
        init (str): Initial jao.
        med (str): Medial jamo.
        final (str): Final jamo. If not supplied, the final syllable is made
            without the final. (default: None)

    Returns:
        A Korean syllable.
    """
    chars = (init, med, final)
    for c in filter(None, chars):
        check_hangul(c, jamo_only=True)

    idx = tuple(CHAR_INDICES[pos][c] if c is not None else c
                for pos, c in zip((INITIAL, MEDIAL, FINAL), chars))
    init_idx, med_idx, final_idx = idx
    # final index must be shifted once as
    # final index with 0 points to syllables without final
    final_idx = 0 if final_idx is None else final_idx + 1
    return chr(0xac00 + 28 * 21 * init_idx + 28 * med_idx + final_idx)


def join_jamos(s, ignore_err=True):
    """
    Combines a sequence of jamos to produce a sequence of syllables.

    Arguments:
        s (str): A string (possible mixed with non-jamo characters).
        ignore_err (bool): If set False, it will ensure that all characters
            will be consumed for the making of syllables. It will throw a
            ValueError when it fails to do so. (default: True)

    Returns:
        A string

    Example:
        >>> join_jamos("ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ")
        "안녕하세요"
        >>> join_jamos("ㅇㅏㄴㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ")
        "안ㄴ녕하세요"
        >>> join_jamos()
    """
    last_t = 0
    queue = []
    new_string = ""

    def flush(n=0):
        new_queue = []
        while len(queue) > n:
            new_queue.append(queue.pop())
        if len(new_queue) == 1:
            if not ignore_err:
                raise ValueError(f"invalid jamo character: {new_queue[0]}")
            result = new_queue[0]
        elif len(new_queue) >= 2:
            try:
                result = join_jamos_char(*new_queue)
            except (ValueError, KeyError):
                # Invalid jamo combination
                if not ignore_err:
                    raise ValueError(f"invalid jamo characters: {new_queue}")
                result = "".join(new_queue)
        else:
            result = None
        return result

    for c in s:
        if c not in CHARSET:
            if queue:
                new_c = flush() + c
            else:
                new_c = c
            last_t = 0
        else:
            t = get_jamo_type(c)
            new_c = None
            if t & FINAL == FINAL:
                if not (last_t == MEDIAL):
                    new_c = flush()
            elif t == INITIAL:
                new_c = flush()
            elif t == MEDIAL:
                if last_t & INITIAL == INITIAL:
                    new_c = flush(1)
                else:
                    new_c = flush()
            last_t = t
            queue.insert(0, c)
        if new_c:
            new_string += new_c
    if queue:
        new_string += flush()
    return new_string

ch_list1 = ['ㅏ','ㅐ','ㅗ','ㅚ','ㅜ','ㅡ'] #두음 1
ch_list2 = ['ㅑ','ㅕ','ㅖ','ㅛ','ㅠ','ㅣ'] #두음 2
ch_list3 = ['ㅕ','ㅛ','ㅠ','ㅣ'] #두음 3

def dueum(word):
  try:
    jamos = extract_last_character(word)
    jamos = split_syllables(jamos) # 단어를 자모 단위로 분리
    jamos_list = list(jamos) # 자모 단위로 분리된 것을 리스트로 변환
    if len(jamos_list) <2:
      error_ch = join_jamos(jamos_list)
      return error_ch
    if jamos_list[1] in ch_list1 and jamos_list[0] == 'ㄹ':
      jamos_list[0] = 'ㄴ'
    elif (jamos_list[1] in ch_list2 and jamos_list[0] == 'ㄹ') or (jamos_list[1] in ch_list3 and jamos_list[0] == 'ㄴ'):
      jamos_list[0] = 'ㅇ'
    modified_word_sub = join_jamos(jamos_list)
    return modified_word_sub
  except SyntaxError or IndexError:
    pass

def extract_last_character(text):
  last_character = None
  if len(text) == 1:
    return '∧'
  if text: # 입력된 텍스트가 비어있지 않은 경우
    last_character = text[-1]# 마지막 글자 추출
  return last_character

def extract_first_character(text):
  first_character = None
  if len(text) <=1:
    return '￢'
  if text: # 입력된 텍스트가 비어있지 않은 경우
    first_character = text[0] # 첫번째 글자 추출
  return first_character

wri_list = []
input_file = input('파일이름을 입력하세요: ')
output_file = input('출력 파일명을 입력하세요: ')
try:
  with open(input_file,'r',encoding='utf-8') as file:
    words = file.read().split()
  for word in words:
    if len(word) <=1:
      pass
    else:
      first_latter = extract_first_character(word)
      sub_first_latter = dueum(first_latter)
      last_character = extract_last_character(word)
      sub_last_character = dueum(word)
      if first_latter == last_character:
        wri_list.append(word)
      elif first_latter == sub_last_character:
        wri_list.append(word)
      elif sub_first_latter == last_character:
        wri_list.append(word)
      elif sub_first_latter == sub_last_character:
        wri_list.append(word)
  wri_list = list(set(wri_list))
  wri_list.sort()
  #wwri_list = []
  for ii in range(len(wri_list)):
    for jj in range(ii + 1, len(wri_list)):

        i = wri_list[ii]
        j = wri_list[jj]

        #print(a, b)
        k1 = extract_first_character(i)
        k2 = dueum(k1)
        kk1 = extract_first_character(j)
        kk2 = dueum(kk1)
        #print(k1,k2,kk1,kk2,i,j)
        if k1 == kk1:
            index_of_3 = wri_list.index(i)
            wri_list.remove(j)
            wri_list.insert(index_of_3 + 1, j)
        elif k1 == kk2:
            index_of_3 = wri_list.index(i)
            wri_list.remove(j)
            wri_list.insert(index_of_3 + 1, j)
        elif k2 == kk1:
            index_of_3 = wri_list.index(i)
            wri_list.remove(j)
            wri_list.insert(index_of_3 + 1, j)
        elif k2 == kk1:
            index_of_3 = wri_list.index(i)
            wri_list.remove(j)
            wri_list.insert(index_of_3 + 1, j)
  with open(output_file,'w',encoding='utf-8') as file:
    file.write('\n'.join(wri_list))
  print(f'{output_file}에 돌림단어들을 저장했습니다.')
except FileNotFoundError:
  print('파일을 찾을수 없습니다.')

"""# X글자수 단어 추출"""

input_file = input('파일이름을 입력하세요: ')
output_file = input('출력파일명을 입력하세요: ')
want_len = int(input('추출을 원하시는 단어수는?: '))
try:
  with open(input_file,'r',encoding='utf-8') as file:
    words = file.read().split()
  out_list = [word for word in words if len(word) == want_len]
  with open(output_file,'w',encoding='utf-8') as file:
    file.write('\n'.join(out_list))
  print(f'{output_file}에 {want_len}글자수인 단어들을 저장했습니다.')
except FileNotFoundError: print('파일을 찾을수 없습니다.')